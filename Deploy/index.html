<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cosmos – GLB 3D Hero Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Three.js + GLTFLoader (non-module, compatible with global THREE) -->
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Inter font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      color-scheme: dark;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background-color: #000;
      color: #f9fafb;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    #hero {
      min-height: 100vh;
      display: grid;
      grid-template-columns: 1fr;
      align-items: center;
      padding: 2rem;
      gap: 2.5rem;
    }
    #hero-text {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }
    #hero-text h1 { margin: 0; }
    #hero-text p { margin-top: 1rem; color: #9ca3af; }
    #grid-panel {
      width: 100%;
      height: 100%;
      max-width: 420px;
      max-height: 420px;
      aspect-ratio: 1 / 1;
      margin: 0 auto;
      position: relative;
      border: 1px solid #374151;
      background-image:
        linear-gradient(to right, rgba(148,163,184,0.18) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(148,163,184,0.18) 1px, transparent 1px);
      background-size: 80px 100%, 100% 80px;
      background-position: center center, center center;
      overflow: hidden;
    }
    #grid-panel canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #glb-status {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      color: #6b7280;
      text-align: center;
      pointer-events: none;
      padding: 0 1rem;
    }
    @media (min-width: 900px) {
      #hero {
        grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
        padding: 4rem;
      }
      #hero-text {
        text-align: left;
        margin-left: 10%;
      }
      #grid-panel {
        margin-right: 10%;
      }
    }
  </style>
</head>
<body>
  <main id="hero">
    <section id="hero-text">
      <h1 class="text-5xl md:text-6xl font-bold text-white">Engineer Your Brand Cosmos</h1>
      <p class="text-xl md:text-2xl">
        GLB test. If you see a floating 3D object in the square, the model is loading correctly.
      </p>
    </section>
    <section id="grid-panel">
      <div id="glb-status">Loading Conflict.glb…</div>
    </section>
  </main>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const container = document.getElementById('grid-panel');
      const statusEl = document.getElementById('glb-status');
      if (!container || !window.THREE || !THREE.GLTFLoader) {
        if (statusEl) statusEl.textContent = 'Three.js or GLTFLoader not available.';
        return;
      }

      const scene = new THREE.Scene();
      scene.background = null;

      const camera = new THREE.PerspectiveCamera(
        35,
        container.clientWidth / container.clientHeight || 1,
        0.1,
        100
      );
      camera.position.set(0, 0, 6);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setClearColor(0x000000, 0);
      container.appendChild(renderer.domElement);

      // lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);
      const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
      keyLight.position.set(3, 4, 6);
      scene.add(keyLight);
      const rimLight = new THREE.DirectionalLight(0x8b5cf6, 1.3);
      rimLight.position.set(-4, 2, -3);
      scene.add(rimLight);

      const loader = new THREE.GLTFLoader();

      loader.load(
        'Conflict.glb',
        function (gltf) {
          let obj = gltf.scene || gltf.scenes[0];
          if (!obj) {
            if (statusEl) statusEl.textContent = 'Conflict.glb loaded but no scene found.';
            return;
          }

          // Normalize size & center
          const box = new THREE.Box3().setFromObject(obj);
          const size = new THREE.Vector3();
          box.getSize(size);
          const maxAxis = Math.max(size.x, size.y, size.z) || 1;
          const scale = 2.4 / maxAxis;
          obj.scale.setScalar(scale);

          box.setFromObject(obj);
          const center = box.getCenter(new THREE.Vector3());
          obj.position.sub(center);

          // Ensure it's visible: add material if missing
          obj.traverse(function (child) {
            if (child.isMesh && !child.material) {
              child.material = new THREE.MeshStandardMaterial({
                color: 0x7c3aed,
                metalness: 0.4,
                roughness: 0.3
              });
            }
          });

          scene.add(obj);

          if (statusEl) statusEl.style.display = 'none';

          const clock = new THREE.Clock();
          function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            obj.rotation.y = t * 0.4;
            obj.rotation.x = Math.sin(t * 0.5) * 0.3;
            renderer.render(scene, camera);
          }
          animate();
        },
        undefined,
        function (err) {
          console.error('Error loading Conflict.glb', err);
          if (statusEl) {
            statusEl.textContent = 'Could not load Conflict.glb. Make sure it is in the same folder as index.html.';
            statusEl.style.color = '#f97373';
          }
        }
      );

      window.addEventListener('resize', function () {
        const width = container.clientWidth;
        const height = container.clientHeight || width || 1;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      });
    });
  </script>
</body>
</html>
